/************************************************************************************
  ATLAS.HX
  Holds a single Atlas
  
  - Tile sequences start at (0)
  - Declare tiles in relation to the last tile with `dtile_()` and `dtile_v()`
  - Declare multipe same sized tiles with `darea()` or `darea_()`
  
  Example
  --------
  
   	var atl = new Atlas("assets/sprits01.png");
	
   .darea_("blocks",0,0,16,8,"th:1")		;	get a single strip of tiles
   .darea_("blocks",0,16,16,8,"tw:4,th:4")	;	append to 'blocks' a 4x4 tile area starting at xy(0,16)
   .darea_("border",96,96,6,8,"tw:4")		;	append to 'border' a rectangle with 4 tiles width, until image ends vertical (staying at 96 pixel x)
   .darea("enemies",8,8,32,32,0,0,5,5)		;	direct variable use, no CSV
  
   .dtile("deco1",10,10,100,100)	;	add a single TILE
   .dtile_("deco2",100,4)			;	add single TILE, that is 4 pixels next to the previous one, 100px width, same height as prev
   .dtile_v("deco3",100,2)			; 	add single TILE, is 2 pixels BELOW the previous one, 100px HEIGHT, same width as prev
  
   .getbi()	; Get Bitmap from ID
   .getbn()	; Get Bitmap from NAME

 **********************************************************************************/

package djfl.util;

import djA.types.SimpleRect;
import djA.DataT;
import openfl.Assets;
import openfl.display.BlendMode;
import openfl.display.BitmapData;
import openfl.geom.Matrix;
import openfl.geom.Point;
import openfl.geom.Rectangle;

@:dce
class Atlas 
{	
	static public var GEN(default, null):Int = 1;
	
	public var id(default, null):String;
	public var pixels(default, null):BitmapData;
	
	public var asset(default,null):String;	// Also keep the asset this asset is from
	
	// Hold ALL declared tiles in an array
	// by the order they are declared
	public var tiles(default, null):Array<SimpleRect>;
	
	// Store Tiles Map, < Tile Sequence ID --> [Raw Indexes] >
	// e.g. <"player_jump",[10,11,12,13]>  , where the array is filled with indexes to work on the `tiles` array
	var tilesM:Map<String,Array<Int>>;
	
	// Keep the last declared tile
	var cursor:SimpleRect;
	
	// General purpose Rectangle and Point for operations
	var r0:Rectangle;
	var p0:Point;
	var rr:SimpleRect;
	
	
	/**
	   @param	assetName
	   @param	id_ Must be unique (null) for autogenerated
	**/
	public function new(assetName:String, id_:String = null) 
	{
		id = id_;
		asset = assetName;
		tiles = [];
		tilesM = [];
		r0 = new Rectangle();
		p0 = new Point();
		
		cursor = new SimpleRect();
		rr = new SimpleRect();
		
		if (id == null)
		{
			// Get a unique name
			assetName = StringTools.replace(assetName, '\\', '/');
			id = (GEN++) + "#" + assetName.split('/').pop();
		}
		
		// DEV: Do not cache the bitmap on OPENFL assets, because it is going to be stored here.
		pixels = Assets.getBitmapData(assetName, false);
		
		trace('Loading Atlas ($assetName) with id ($id)');
	}//---------------------------------------------------;
	
	
	/**
	   Alternative to `darea()` but will work with CSV values for the last parameters
	   Created for ease of use.
	   e.g. darea_("id",0,0,16,16,"px:3,py:2,tc:3");
	   @param	csv px,py,tw,th,tc
	**/
	public function darea_(id:String, x:Int, y:Int, w:Int, h:Int, csv:String):Array<Int>
	{
		var t = DataT.getCSVTable(csv);
		
		return darea(id, x, y, w, h,
				DataT.intOrZeroFromStr(t.get('px')),
				DataT.intOrZeroFromStr(t.get('py')),
				DataT.intOrZeroFromStr(t.get('tw')),
				DataT.intOrZeroFromStr(t.get('th')),
				DataT.intOrZeroFromStr(t.get('tc'))
			);
	}//---------------------------------------------------;
	
	/**
	   Declare an Area of Tiles
	   - Scans From Top Left to Bottom Right , Horizontally.
	   - Get the tiles with get("id",number)
	   - e.g. if darea("id",0,0,16,16) ==> Will read the entire atlas
	   @param	id TileSet ID, if same name exists, numbers will append. 
	   @param	x Start X
	   @param	y Start Y
	   @param	w Tile Width
	   @param	h Tile Height
	   @param	px X Padding, (0)
	   @param	py Y Padding, (0)
	   @param	TW Width in Tiles to scan, (0) for full scan ahead. {Negative values} for Pixel Based
	   @param	TH Height in Tiles to scan, (0) for full scan ahead. {Negative values} for Pixel Based
	   @param	TC TileCount. Get this many tiles from the strip. (0) for no effect
	   @return
	**/
	public function darea(id:String, x:Int, y:Int, w:Int, h:Int, px:Int = 0, py:Int = 0, TW:Int = 0, TH:Int = 0, TC:Int = 0):Array<Int>
	{
		var ar:Array<Int>;
		if (tilesM.exists(id)) {
			ar = tilesM.get(id); // Append the new tiles
		}else{
			ar = [];
		}
		
		var j = 0; // Tiles processed
		
		if (TW > 0) // Convert Tiles to actual dimensions
		{
			TW = (TW * (w + px)) - px;
		}else
		{
			TW = -TW;
		}
		
		if (TH > 0) 
		{
			TH = (TH * (h + py)) - py;
		}else
		{
			TH = -TH;
		}
		
		// DEV: From here TW,TH are converted to real pixels metrics.
		
		var C = new SimpleRect(x, y, w, h); // Temp cursor
		var end:Bool = false;
		
		function _newline(sx:Int) // (sx=startx)
		{
			C.x = sx; C.y += h + py;
			if (TH > 0){
				if (C.y + h > y + TH) end = true;
			}else{
				if (C.y + h > pixels.height) end = true;
			}
		}//--
		
		while (!end)
		{
			// C is a valid rect, get it and figure out the next Position in C
			cursor = C.clone();
			ar.push(tiles.length);	// If first element will push (0) the current index.
			tiles.push(cursor); 
			j++;
			
			if (TC > 0 && j == TC) 
				break; // DEV: don't use `end` var, I can just break now
			
			C.x += w + px;
			if (TW > 0)
			{
				if (C.x + w > x + TW) 
					_newline(x);
			}else{
				if (C.x + w > pixels.width)
					_newline(0);
			}
		}
		
		//trace('Add tile id="$id", len=${ar.length}');
		tilesM.set(id, ar); // DEV: Will overwrite if exist
		return ar;
	}//---------------------------------------------------;
	
	
	/** 
	  Declare Single Tile 
	  - If tilename exists, it will append it as the next frame in sequence
	  @
	  @return tile Index
	 **/
	public function dtile(id:String,x:Int,y:Int,w:Int,h:Int):Int
	{
		var ar:Array<Int>;
		if (tilesM.exists(id)) {
			ar = tilesM.get(id); // Append the new tiles
		}else{
			ar = [];
		}
		// Point to the last tile stored
		cursor = SimpleRect.get(x, y, w, h);
		ar.push(tiles.length);
		tiles.push(cursor);		
		tilesM.set(id, ar);
		//trace('Add tile, id="$id", SeqLen = "${ar.length}"');
		
		return ar[ar.length - 1];
	}//---------------------------------------------------;
	
	
	/**
	   Declare in relation to the last declared tile ending pos >> HORIZONTALLY >>
	   - If tilename exists, it will append it as the next frame in sequence
	   - New tile HEIGHT must be the same as previous declared
	   The new declared HEIGHT should be the same as Cursor
	   @return tile Index
	**/
	public function dtile_(id:String, w:Int, pad:Int = 0):Int
	{
		return dtile(id, cursor.x + cursor.w + pad, cursor.y, w, cursor.h);
	}//---------------------------------------------------;
	
	/**
	   Declare in relation to the last declared tile ending pos || VERTICALLY ||
	   - If tilename exists, it will append it as the next frame in sequence
	    - New tile WIDTH must be the same as previous declared
		@return tile Index
	**/
	public function dtile_v(id:String, h:Int, pad:Int = 0):Int
	{
		return dtile(id, cursor.x, cursor.y + cursor.h + pad, cursor.w, h);
	}//---------------------------------------------------;

	
	//====================================================;
	// Getting Bitmapdata 
	//====================================================;
	
	
	/**
	   Get (B)itmap data of a tile sequence from tile (Name). 
	   Specify index/frame staring at [0]
	**/
	public function get_bn(name:String, index:Int = 0):BitmapData
	{
		return get_bi(tilesM.get(name)[index]);
	}//---------------------------------------------------;
	
	
	/**
	   Get Tile BitmapData from Tile (I)ndex
	**/
	public function get_bi(i:Int):BitmapData
	{
		rr = tiles[i];
		var surface = new BitmapData(rr.w, rr.h, true, 0x00000000);
		r0.setTo(rr.x, rr.y, rr.w, rr.h);
		surface.copyPixels(pixels, r0, p0);
		return surface;
	}//---------------------------------------------------;	
	
	
	/**
	   Get Tile Rect array from a tile sequence name
	   Returns an array with indexes for the rects in the `tiles` Array
	**/
	public function get_indexes(id:String):Array<Int>
	{
		return tilesM.get(id);
	}//---------------------------------------------------;
	
	
	/**
	   Draw (real) Tile Index at a Bitmapdata
	**/
	public function drawAt(i:Int, b:BitmapData, x:Float = 0, y:Float = 0)
	{
		rr = tiles[i];
		r0.setTo(rr.x, rr.y, rr.w, rr.h);
		p0.setTo(x, y);
		b.copyPixels(pixels, r0, p0);
		p0.setTo(0, 0);	// Reset it because other functions use it
	}//---------------------------------------------------;
	
	/**
	   Draw (Rect) at bitmapdata
	**
	public function drawAtR(r:SimpleRect, b:BitmapData)
	{
		r0.setTo(r.x, r.y, r.w, r.h);
		b.copyPixels(pixels, r0, p0);
	}//---------------------------------------------------; */
	
	
	/**
	   Return all (R)ectangles belonging to a tile name.
	   -- not sure I need this one? --
	
	public function get_r(id:String):Array<SimpleRect>
	{
		var r:Array<SimpleRect> = [];
		var ar = tilesM.get(id);
		if (ar == null) return null;
		for (i in ar){
			r.push(tiles[i]);
		}
		return r;
	}*///---------------------------------------------------;
	
	/**
	   Get (B)itmapData from a (R)ectangle in the Atlas
	   e.g.
	**
	public function get_br(r:SimpleRect):BitmapData
	{
		var surface = new BitmapData(r.w, r.h, true, 0x00000000);
		r0.setTo(r.x, r.y, r.w, r.h);
		surface.copyPixels(pixels, r0, p0);
		return surface;
	}*///---------------------------------------------------;
	
	
	/**
	   Get (B)itmapData from a (R)ectangle in the Atlas
	   But use BitmapData.DRAW() instead of copypixels
	   @param	r
	   @return
	**
	public function get_br2(r:SimpleRect):BitmapData
	{
		var surface = new BitmapData(r.w, r.h, true, 0x00000000);
		m0.setTo(1, 0, 0, 1, -r.x, -r.y);
		surface.draw(pixels, m0, null, null, null, true);
		return surface;
	} *///---------------------------------------------------;
	
	
	/**
	   Get bitmapdata from Tile (I)ndex
	   - USE .DRAW() and MATRIX()
	*
	public function get_bi2(i:Int):BitmapData
	{
		rr = tiles[i];
		var surface = new BitmapData(rr.w, rr.h, true, 0x00000000);
		m0.setTo(1, 0, 0, 1, -rr.x, -rr.y);
		surface.draw(pixels, m0);
		return surface;
	}*///---------------------------------------------------;
	
}// --